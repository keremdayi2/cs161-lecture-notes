# CS 161 Lecture Notes: Wednesday, 2/2/2022
*Topics*: Interrupts, Buddy Allocation, and Testing

### Vectoring Control to the Kernel
* Kernel runs code in response to external stimuli
    * Async interrupts: timer interrupt, network cards, etc.
    * Sync interrupts: with respect to the code generating the exception: division by zero, dereferencing a `nullptr`
    * Sync traps: system calls via `syscall` or debugging traps via `int3`
* During boot, the kernel must configure the processor to invoke the appropriate kernel code when exceptions, traps, and interrupts occur
### Interrupts, Exceptions, and Non-Syscall Traps
In `x86-64.h`: Listing the IDT numbers
* `INT_BP`: breakpoint interrupt: when we have a program to debug and want to debug with GDB. GDB overwrites the breakpoint instruction with `int3` which triggers the breakpoint interrupt. GDB remembers that it overwrote the code with `int3` and gdb restores that instruction later.
* `INT_UD`: Invalid opcode: not all binary sequences correspond to valid instructions. When the cpu encounters this instruction, it triggers `INT_UD` interrupt
* `INT_PF`: Page fault. When a virtual address comes to the processor, looks at TLB (cache for address translation). If is a miss, look at pagetable for PTE corresponding to VA, if found add to TLB. Otherwise, raise page fault. 
* In `kernel.hh`, there are `INT_IRQ` (base for hardware interrupts, interrupt request), `IRQ_TIMER`, `IRQ_KEYBOARD`. These are hardware generated interrupts.
### Which Stack Should the Kernel Use to Handle Interrupts and Exceptions?
System calls:
* A system call asks the kernel to perform work on behalf of a particular process. 
* So, most OSes (including Chickadee) use a per-process kernel stack to handle system calls. (overallocated `struct proc`, upper part is used for kernel stack).
* Chickadee's `k-exception.S::syscall_entry` immediately switches to that stack: call `swapgs`, then execute `movq %gs:(8), %rsp` which is the current `proc*` pointer. Then, we do `addq $PROCSTACK_SIZE, %rsp` which points to the top of the per-process stack.

**Interrupts & Exceptions**:
Synchronous exceptions/traps are generated by the currently-running process (e.g. divide-by-zero, invalid decode, page fault, debugging trap)\
Async interrupts may not be related to the currently-running process (e.g. interrupts raised by IO devices)

Interrupt-Descriptor-Table Register (IDTR) points to Interrupt Descriptor Table (IDT) in kernel-virtual memory. The hardware takes the interrupt number and multiplies it by 16 and uses it as an offset to virtual address of interrupt-descriptor-table. That memory is a pointer to the kernel code (first instruction) handling that particular interrupt.

**Which stack do we use????**: Global descriptor table register (GDTR) points to Global descriptor table. TSS (task state segment) descriptor which contains the virtual address of Task State Segment. This includes a bunch of `%rsp` pointers for each interrupt-handler.

In `k-init.cc`, look at `cpustate::init_cpu_hardware()`. Why do we want more than 1 stack (CPU stack and CPU alternative stack)? Uses alternate stack for a small set of interrupts and exceptions (if machine is broken, non-maskable interrupts, ) `INT_DB` debugging interrupt, `INT_NM` non-maskable interrupt (RAM error or another unrecoverable hardware error), `INT_MC` machine-check interrupt (unrecoverable hardware errors). When these interrupts fire, the hardware might be sufficiently messed up that the regular interrupt-handler stack is corrupted!

OSdev website: I can't get interrupts working!

The hardware automatically disables interrupts before executing the kernel's interrupt handler!
* Modern OSes can disable interrupts for the shortest time possible to be more responsive: for instance, network cards want to flush their buffer as soon as possible. There are multiple interrupt priorities.

The hardware also pushes some registers onto the stack! We need to change priviledge `%cs` from 3 to 0.

Exceptions & interrupts that occur in kernel mode: No priviledge change is needed. Then, the registers are pushed onto the current stack (the kernel stack). What `%rsp` happens to be at the time.

In `k-exception.S`, we look at `exception_entry`. Design choice: to the greatest extent possible, chickadee should use a per-process kernel stack for all kernel code: exception handling, syscall handling, and interrupt handling!
* Priviledge levels in `x86-64`: rings, 0-3. 0 most priviledged, 3 least.
* In `exception_entry` we check which priviledge mode the exception happened in.
* We copy registers from CPU stack to the kernel task stack.
* We are saving the process' registers by pushing them onto the stack.
* When we are returning from the exception, we use `restore_and_iret`. Check `proc::pstate_` which stores the state of process. 
* While returning, we pop the saved registers on the stack back to the registers.
* Returning to user code: `cli` disable interrupts, `swapgs`, `pop %gs`, `addq $16, %rsp` (discarding stuff that is on the stack, the error code, interrupt number), then `iretq` pops the remaining 5 things, sets `%rip`, `%rsp` etc, and enables interrupts. Goes back to user-mode context.

**What does `proc::exception()` do**: looks at interrupt number cases via `switch`. 
* *Timer interrupt case*: check if `cpunindex_ == 0` and increment `ticks`. Set `regs_ = regs` argument vs. for procs. `yield_noreturn()`: important for context switches, implemented in `k-exception.S`. A process is giving up the cpu via `yield_noreturn()`.
    * The first argument of `proc::yield_noreturn()` is `this` pointer, which is stored in `%rdi`.
    * Get a pointer to the cpustate of the current cpu.
    * Set `%rsp` to the virtual address that is located at `%gs:(0) + CPUSTACK_SIZE`.

### The Mystery of `proc::regs_`
If a process has a non-null `proc::regs_`:
* The process has a full set of saved registers on its kernel stack that must be restored because the process was interrupted/exceptioned.
* The process is new; the callchain kicked off by `boot_process_start(pid_t pid, const char* name)`.

So, `proc::regs_` can be `nullptr`! 
* Ex: User-level code does a `getpid()` system call, where the kernel handles the request and then immediately returns to user-mode. 